#!/bin/bash
## CUSTOM-UTIL: File automatically created/updated [custom-util-ha]

#
#       OCF Resource Agent compliant drbd resource script.
#
# Copyright (c) 2004 - 2007 SUSE LINUX Products GmbH, Lars Marowsky-Bree
#                    All Rights Reserved.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of version 2 of the GNU General Public License as
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it would be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
#
# Further, this software is distributed without any warranty that it is
# free of the rightful claim of any third person regarding infringement
# or the like.  Any license provided herein, whether implied or
# otherwise, applies only to this software file.  Patent licenses, if
# any, provided herein do not apply to combinations of this program with
# other software, or any other product whatsoever.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write the Free Software Foundation,
# Inc., 59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
#
#

# OCF instance parameters
#  OCF_RESKEY_resource
#  OCF_RESKEY_conf


# Dependencies

if [ -n "$OCF_DEBUG_LIBRARY" ]; then
  . $OCF_DEBUG_LIBRARY
else
  . ${OCF_ROOT}/resource.d/heartbeat/.ocf-shellfuncs
fi

#######################################################################

meta_data() {
  cat <<END
<?xml version="1.0"?>
<!DOCTYPE resource-agent SYSTEM "ra-api-1.dtd">
<resource-agent name="DRBDResource">
<version>1.1</version>

<longdesc lang="en">
OCF Resource Agent for DRBD resource
</longdesc>

<shortdesc lang="en">
Distributed Replicated Block Device (DRBD) resource management script.
</shortdesc>

<parameters>
<parameter name="resource" unique="1" required="1">
<longdesc lang="en">The name of the DRBD resource.</longdesc>
<shortdesc lang="en">DRBD resource name</shortdesc>
<content type="string" default="drbd0" />
</parameter>

<parameter name="conf">
<longdesc lang="en">Full path to the drbd.conf file.</longdesc>
<shortdesc lang="en">Path to drbd.conf</shortdesc>
<content type="string" default="/etc/drbd.conf"/>
</parameter>
</parameters>

<actions>
<action name="start" timeout="60" />
<action name="stop" timeout="60" />
<action name="monitor" depth="0" timeout="5" interval="5" start-delay="60" />
<action name="meta-data" timeout="5" />
<action name="validate-all" timeout="5" />
</actions>
</resource-agent>
END

  exit $OCF_SUCCESS
}

do_cmd() {
  local cmd="$*"
  ocf_log debug "$RESOURCE: Calling $cmd"
  local cmd_out=$($cmd 2>&1)
  ret=$?
  
  if [ $ret -ne 0 ]; then
    ocf_log err "$RESOURCE: Called $cmd"
    ocf_log err "$RESOURCE: Exit code $ret"
    ocf_log err "$RESOURCE: Command output: $cmd_out"
  else
    ocf_log debug "$RESOURCE: Exit code $ret"
    ocf_log debug "$RESOURCE: Command output: $cmd_out"
  fi
  
  echo $cmd_out
  
  return $ret
}

do_drbdadm() {
  local cmd="$DRBDADM -c $DRBDCONF $*"
  ocf_log debug "$RESOURCE: Calling $cmd"
  local cmd_out=$($cmd 2>&1)
  ret=$?
  # Trim the garbage drbdadm likes to print when using the node
  # override feature:
  local cmd_ret=$(echo $cmd_out | sed -e 's/found __DRBD_NODE__.*<<//;')
  
  if [ $ret -ne 0 ]; then
    ocf_log err "$RESOURCE: Called $cmd"
    ocf_log err "$RESOURCE: Exit code $ret"
    ocf_log err "$RESOURCE: Command output: $cmd_ret"
  else
    ocf_log debug "$RESOURCE: Exit code $ret"
    ocf_log debug "$RESOURCE: Command output: $cmd_ret"
  fi
  
  echo $cmd_ret
  
  return $ret
}

drbd_init() {
  check_binary $DRBDADM
  
  RESOURCE="$OCF_RESKEY_resource"
  DRBDCONF="${OCF_RESKEY_conf:=/etc/drbd.conf}"

  if [ ! -f "$DRBDCONF" ]; then
    ocf_log err "$DRBDCONF not installed."
    if [ '$ACTION' = 'monitor' ]; then
      exit $OCF_NOT_RUNNING
    else
      exit $OCF_ERR_INSTALLED
    fi
  fi

}

#######################################################################

drbd_usage() {
  cat <<END
usage: $0 {start|stop|monitor|validate-all|meta-data}

Expects to have a fully populated OCF RA-compliant environment set.
END
}

is_drbd_enabled () {
  if [ -f /proc/drbd ]; then
    return 0
  fi
  return 1
}


drbd_get_status() {
  DRBD_STATE=$(do_drbdadm role $RESOURCE)
  DRBD_STATE_LOCAL=${DRBD_STATE%%/*}
  DRBD_STATE_REMOTE=${DRBD_STATE##*/}

  # Sanitize the various states, drbdadm is quite annoying; so if it 
  # outputs something which doesn't make sense, translate it into
  # a harmless state:

  case "$DRBD_STATE_LOCAL" in
    "Primary"|"Secondary") ;;
    *) DRBD_STATE_LOCAL="Invalid" ;;
  esac

  case "$DRBD_STATE_REMOTE" in
    "Primary"|"Secondary") ;;
    *) DRBD_STATE_REMOTE="Invalid" ;;
  esac

  ocf_log debug "$RESOURCE status: $DRBD_STATE $DRBD_STATE_LOCAL $DRBD_STATE_REMOTE"
}

drbd_start() {
  if is_drbd_enabled; then
    : OK
  else
    ocf_log err "$RESOURCE start: DRBD not enabled"
    return $OCF_ERR_GENERIC 
  fi

  drbd_get_status
  if [ "$DRBD_STATE_LOCAL" == "Primary" ]; then
    ocf_log debug "$RESOURCE start: already Primary"
    return $OCF_SUCCESS
  fi

  if do_drbdadm primary $RESOURCE ; then
    sleep 1
    drbd_get_status
    n=15; while [ "$DRBD_STATE_LOCAL" != "Primary" -a $n -gt 0 ]; do
      let n=n-1
      ocf_log debug "$RESOURCE stop: waiting to switch to Primary..."
      sleep 1
      drbd_get_status
    done
    if [ "$DRBD_STATE_LOCAL" != "Primary" ]; then
      ocf_log err "$RESOURCE start: failed to switch to Primary"
      return $OCF_ERR_GENERIC
    fi

    ocf_log debug "$RESOURCE start: succeeded"
    return $OCF_SUCCESS
  else
    ocf_log err "$RESOURCE start: failed to start (non-zero exit code)"
    return $OCF_ERR_GENERIC
  fi
}

drbd_stop() {
  # Do not bother if drbd is not enabled
  if is_drbd_enabled; then
    drbd_get_status
    if [ "$DRBD_STATE_LOCAL" == "Secondary" ]; then
      ocf_log debug "$RESOURCE stop: already Secondary"
      return $OCF_SUCCESS
    fi

    if do_drbdadm secondary $RESOURCE ; then
      sleep 1
      drbd_get_status
      n=15; while [ "$DRBD_STATE_LOCAL" != "Secondary" -a $n -gt 0 ]; do
        let n=n-1
        ocf_log debug "$RESOURCE stop: waiting to switch to Secondary..."
        sleep 1
        drbd_get_status
      done
      if [ "$DRBD_STATE_LOCAL" != "Secondary" ]; then
        ocf_log err "$RESOURCE stop: failed to switch to Secondary"
        return $OCF_ERR_GENERIC
      fi

      ocf_log debug "$RESOURCE stop: succeeded"
      return $OCF_SUCCESS
    else
       ocf_log err "$RESOURCE stop: failed to stop (non-zero exit code)"
       return $OCF_ERR_GENERIC
    fi

  fi
  return $OCF_SUCCESS
}

drbd_monitor() {
  if is_drbd_enabled; then
    : OK
  else
    ocf_log warn "$RESOURCE monitor: DRBD not enabled"
    return $OCF_NOT_RUNNING
  fi

  drbd_get_status
  if [ "$DRBD_STATE_LOCAL" == "Primary" ]; then
    return $OCF_SUCCESS
  elif [ "$DRBD_STATE_LOCAL" == "Secondary" ]; then
    return $OCF_NOT_RUNNING
  else
    ocf_log err "$RESOURCE monitor: unexpected local state: $DRBD_STATE_LOCAL"
  fi
  
  return $OCF_ERR_GENERIC
}


drbd_validate_all () {
  # First check the configuration file
  if [ -n "$DRBDCONF" ] && [ ! -f "$DRBDCONF" ]; then
    ocf_log err "Configuration file does not exist: $DRBDCONF"
    return $OCF_ERR_CONFIGURED
  fi

  # Check the resource name, it should appear in DRBDCONF
  if [ -z "$RESOURCE" ]; then
    ocf_log err "No resource name specified!"
    return $OCF_ERR_ARGS
  fi
  
  if do_drbdadm dump $RESOURCE 2>/dev/null ; then
    :
  else
    ocf_log err "Invalid configuration file $DRBDCONF"
    return $OCF_ERR_CONFIGURED
  fi
  
  return $OCF_SUCCESS
}


if [ $# -ne 1 ]; then
  echo "Incorrect parameter count."
  drbd_usage
  exit $OCF_ERR_ARGS
fi

ACTION=$1
case $ACTION in

  meta-data)
    meta_data
    ;;

  validate-all)
    drbd_init
    drbd_validate_all
    ;;

  start|stop|monitor)
    if ocf_is_root ; then : ; else
      ocf_log err "You must be root to perform this operation."
      exit $OCF_ERR_PERM
    fi
  
    drbd_init
    drbd_$ACTION
    exit $?
    ;;

  promote|demote|notify)
    exit $OCF_ERR_UNIMPLEMENTED
    ;;

  usage|help)
    drbd_usage
    exit $OCF_SUCCESS
    ;;

  *)
    drbd_usage
    exit $OCF_ERR_ARGS
    ;;

esac

